{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mezzio-authorization-rbac This library provides a laminas-rbac adapter for mezzio-authorization. Installation Run the following to install this library: $ composer require mezzio/mezzio-authorization-rbac Documentation Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Home"},{"location":"#mezzio-authorization-rbac","text":"This library provides a laminas-rbac adapter for mezzio-authorization.","title":"mezzio-authorization-rbac"},{"location":"#installation","text":"Run the following to install this library: $ composer require mezzio/mezzio-authorization-rbac","title":"Installation"},{"location":"#documentation","text":"Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Documentation"},{"location":"v1/basic-usage/","text":"Basic Usage Configure an RBAC system You can configure your RBAC using a configuration file, as follows: // config/autoload/authorization.local.php return [ // ... 'mezzio-authorization-rbac' =&gt; [ 'roles' =&gt; [ 'administrator' =&gt; [], 'editor' =&gt; ['administrator'], 'contributor' =&gt; ['editor'], ], 'permissions' =&gt; [ 'contributor' =&gt; [ 'admin.dashboard', 'admin.posts', ], 'editor' =&gt; [ 'admin.publish', ], 'administrator' =&gt; [ 'admin.settings', ], ], ] ]; In the above example, we designed an RBAC system with 3 roles: administator , editor , and contributor . We defined a hierarchy of roles as follows: administrator has no parent role. editor has administrator as a parent. That means administrator inherits the permissions of the editor . contributor has editor as a parent. That means editor inherits the permissions of contributor , and following the chain, administator inherits the permissions of contributor . For each role, we specified an array of permissions. As you can notice, a permission is just a string; it can represent anything. In our implementation, this string represents a route name. That means the contributor role can access the routes admin.dashboard and admin.posts but cannot access the routes admin.publish (assigned to editor role) and admin.settings (assigned to administrator ). Custom Authorization Logic If you want to change the authorization logic for each permission, you can write your own Mezzio\\Authorization\\AuthorizationInterface implementation. That interface defines the following method: isGranted(string $role, ServerRequestInterface $request): bool; where $role is the role and $request is the PSR-7 HTTP request to authorize.","title":"Basic Usage"},{"location":"v1/basic-usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"v1/basic-usage/#configure-an-rbac-system","text":"You can configure your RBAC using a configuration file, as follows: // config/autoload/authorization.local.php return [ // ... 'mezzio-authorization-rbac' =&gt; [ 'roles' =&gt; [ 'administrator' =&gt; [], 'editor' =&gt; ['administrator'], 'contributor' =&gt; ['editor'], ], 'permissions' =&gt; [ 'contributor' =&gt; [ 'admin.dashboard', 'admin.posts', ], 'editor' =&gt; [ 'admin.publish', ], 'administrator' =&gt; [ 'admin.settings', ], ], ] ]; In the above example, we designed an RBAC system with 3 roles: administator , editor , and contributor . We defined a hierarchy of roles as follows: administrator has no parent role. editor has administrator as a parent. That means administrator inherits the permissions of the editor . contributor has editor as a parent. That means editor inherits the permissions of contributor , and following the chain, administator inherits the permissions of contributor . For each role, we specified an array of permissions. As you can notice, a permission is just a string; it can represent anything. In our implementation, this string represents a route name. That means the contributor role can access the routes admin.dashboard and admin.posts but cannot access the routes admin.publish (assigned to editor role) and admin.settings (assigned to administrator ).","title":"Configure an RBAC system"},{"location":"v1/basic-usage/#custom-authorization-logic","text":"If you want to change the authorization logic for each permission, you can write your own Mezzio\\Authorization\\AuthorizationInterface implementation. That interface defines the following method: isGranted(string $role, ServerRequestInterface $request): bool; where $role is the role and $request is the PSR-7 HTTP request to authorize.","title":"Custom Authorization Logic"},{"location":"v1/dynamic-assertion/","text":"Dynamic Assertion In some cases you will need to authorize a role based on a specific HTTP request. For instance, imagine that you have an \"editor\" role that can add/update/delete a page in a Content Management System (CMS). We want to prevent an \"editor\" from modifying pages they have not created. These types of authorization are called dynamic assertions and are implemented via the Laminas\\Permissions\\Rbac\\AssertionInterface of laminas-permissions-rbac . Interfaces In order to use it, this package provides LaminasRbacAssertionInterface , which extends Laminas\\Permissions\\Rbac\\AssertionInterface : namespace Mezzio\\Authorization\\Rbac; use Psr\\Http\\Message\\ServerRequestInterface; use Laminas\\Permissions\\Rbac\\AssertionInterface; interface LaminasRbacAssertionInterface extends AssertionInterface { public function setRequest(ServerRequestInterface $request) : void; } The Laminas\\Permissions\\Rbac\\AssertionInterface defines the following: namespace Laminas\\Permissions\\Rbac; interface AssertionInterface { public function assert(Rbac $rbac, RoleInterface $role, string $permission) : bool; } Example Going back to our use case, we can build a class to manage the \"editor\" authorization requirements, as follows: use Mezzio\\Authorization\\Rbac\\LaminasRbacAssertionInterface; use App\\Service\\Article; class EditorAuth implements LaminasRbacAssertionInterface { public function __construct(Article $article) { $this-&gt;article = $article; } public function setRequest(ServerRequestInterface $request) { $this-&gt;request = $request; } public function assert(Rbac $rbac, RoleInterface $role, string $permission) { $user = $this-&gt;request-&gt;getAttribute(UserInterface::class, false); return $this-&gt;article-&gt;isUserOwner($user-&gt;getIdentity(), $this-&gt;request); } } Where Article is a class that checks if the identified user is the owner of the article referenced in the HTTP request. If you manage articles using a SQL database, the implementation of isUserOwner() might look like the following: public function isUserOwner(string $identity, ServerRequestInterface $request): bool { // get the article {article_id} attribute specified in the route $url = $request-&gt;getAttribute('article_id', false); if (! $url) { return false; } $sth = $this-&gt;pdo-&gt;prepare( 'SELECT * FROM article WHERE url = :url AND owner = :identity' ); $sth-&gt;bindParam(':url', $url); $sth-&gt;bindParam(':identity', $identity); if (! $sth-&gt;execute()) { return false; } $row = $sth-&gt;fetch(); return ! empty($row); } To pass the Article dependency to your assertion, you can use a Factory class that generates the EditorAuth class instance, as follows: use App\\Service\\Article; class EditorAuthFactory { public function __invoke(ContainerInterface $container) : EditorAuth { return new EditorAuth( $container-&gt;get(Article::class) ); } } And configure the service container to use EditorAuthFactory to point to EditorAuth , using the following configuration: return [ 'dependencies' =&gt; [ 'factories' =&gt; [ // ... EditorAuth::class =&gt; EditorAuthFactory::class ] ] ];","title":"Dynamic Assertion"},{"location":"v1/dynamic-assertion/#dynamic-assertion","text":"In some cases you will need to authorize a role based on a specific HTTP request. For instance, imagine that you have an \"editor\" role that can add/update/delete a page in a Content Management System (CMS). We want to prevent an \"editor\" from modifying pages they have not created. These types of authorization are called dynamic assertions and are implemented via the Laminas\\Permissions\\Rbac\\AssertionInterface of laminas-permissions-rbac .","title":"Dynamic Assertion"},{"location":"v1/dynamic-assertion/#interfaces","text":"In order to use it, this package provides LaminasRbacAssertionInterface , which extends Laminas\\Permissions\\Rbac\\AssertionInterface : namespace Mezzio\\Authorization\\Rbac; use Psr\\Http\\Message\\ServerRequestInterface; use Laminas\\Permissions\\Rbac\\AssertionInterface; interface LaminasRbacAssertionInterface extends AssertionInterface { public function setRequest(ServerRequestInterface $request) : void; } The Laminas\\Permissions\\Rbac\\AssertionInterface defines the following: namespace Laminas\\Permissions\\Rbac; interface AssertionInterface { public function assert(Rbac $rbac, RoleInterface $role, string $permission) : bool; }","title":"Interfaces"},{"location":"v1/dynamic-assertion/#example","text":"Going back to our use case, we can build a class to manage the \"editor\" authorization requirements, as follows: use Mezzio\\Authorization\\Rbac\\LaminasRbacAssertionInterface; use App\\Service\\Article; class EditorAuth implements LaminasRbacAssertionInterface { public function __construct(Article $article) { $this-&gt;article = $article; } public function setRequest(ServerRequestInterface $request) { $this-&gt;request = $request; } public function assert(Rbac $rbac, RoleInterface $role, string $permission) { $user = $this-&gt;request-&gt;getAttribute(UserInterface::class, false); return $this-&gt;article-&gt;isUserOwner($user-&gt;getIdentity(), $this-&gt;request); } } Where Article is a class that checks if the identified user is the owner of the article referenced in the HTTP request. If you manage articles using a SQL database, the implementation of isUserOwner() might look like the following: public function isUserOwner(string $identity, ServerRequestInterface $request): bool { // get the article {article_id} attribute specified in the route $url = $request-&gt;getAttribute('article_id', false); if (! $url) { return false; } $sth = $this-&gt;pdo-&gt;prepare( 'SELECT * FROM article WHERE url = :url AND owner = :identity' ); $sth-&gt;bindParam(':url', $url); $sth-&gt;bindParam(':identity', $identity); if (! $sth-&gt;execute()) { return false; } $row = $sth-&gt;fetch(); return ! empty($row); } To pass the Article dependency to your assertion, you can use a Factory class that generates the EditorAuth class instance, as follows: use App\\Service\\Article; class EditorAuthFactory { public function __invoke(ContainerInterface $container) : EditorAuth { return new EditorAuth( $container-&gt;get(Article::class) ); } } And configure the service container to use EditorAuthFactory to point to EditorAuth , using the following configuration: return [ 'dependencies' =&gt; [ 'factories' =&gt; [ // ... EditorAuth::class =&gt; EditorAuthFactory::class ] ] ];","title":"Example"},{"location":"v1/installation/","text":"This Is Only a Placeholder The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"Installation"},{"location":"v1/installation/#this-is-only-a-placeholder","text":"The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"This Is Only a Placeholder"},{"location":"v1/intro/","text":"Introduction This component provides Role-Based Access Control (RBAC) authorization abstraction for the mezzio-authorization library. Roles, Identities, Permissions RBAC is based on the idea of roles . In a web application, users have an identity (e.g. username, email, etc). Each identified user then has one or more roles (e.g. admin, editor, guest). Each role has a permission to perform one or more actions (e.g. access an URL, execute specific web API calls). In a typical RBAC system: A role requests access to a permission. An identity has one or more roles. A permission is given to a role. Thus, RBAC has the following model: Many-to-many relationship between identities and roles. Many-to-many relationship between roles and permissions. Roles can have a parent role. The first requirement for an RBAC system is identities . In our scenario, the users are generated by an authentication system, provided by mezzio-authentication . That library provides a PSR-7 request attribute named Mezzio\\Authentication\\UserInterface when a user is authenticated. The RBAC system uses this instance to get information about the user's identity. laminas-permissions-rbac This library uses the laminas/laminas-permissions-rbac library to implement the RBAC system. If you want to know more about the usage of this library, read the blog post Manage permissions with laminas-permissions-rbac .","title":"Introduction"},{"location":"v1/intro/#introduction","text":"This component provides Role-Based Access Control (RBAC) authorization abstraction for the mezzio-authorization library.","title":"Introduction"},{"location":"v1/intro/#roles-identities-permissions","text":"RBAC is based on the idea of roles . In a web application, users have an identity (e.g. username, email, etc). Each identified user then has one or more roles (e.g. admin, editor, guest). Each role has a permission to perform one or more actions (e.g. access an URL, execute specific web API calls). In a typical RBAC system: A role requests access to a permission. An identity has one or more roles. A permission is given to a role. Thus, RBAC has the following model: Many-to-many relationship between identities and roles. Many-to-many relationship between roles and permissions. Roles can have a parent role. The first requirement for an RBAC system is identities . In our scenario, the users are generated by an authentication system, provided by mezzio-authentication . That library provides a PSR-7 request attribute named Mezzio\\Authentication\\UserInterface when a user is authenticated. The RBAC system uses this instance to get information about the user's identity.","title":"Roles, Identities, Permissions"}]}